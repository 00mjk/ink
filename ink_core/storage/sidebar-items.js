initSidebarItems({"derive":[["Flush",""]],"mod":[["alloc","Facilities to allocate and deallocate contract storage dynamically."],["binary_heap","A binary heap collection. The heap depends on `Ord` and is a max-heap by default. In order to make it a min-heap implement the `Ord` trait explicitly on the type which is stored in the heap."],["bitvec","A space-efficient contiguous growable bit array type."],["btree_map","A BTreeMap collection."],["cell","Provides low-level primitive cell types."],["chunk","Provides low-level primitives to operate on chunks of cells."],["hash_map","A hash map implemented with quadratic probing."],["stash","A stash collection."],["vec","A contiguous growable array type, written `Vec<T>` but pronounced 'vector'."]],"struct":[["BTreeMap","Mapping stored in the contract storage."],["BinaryHeap","A binary heap collection. The heap depends on `Ord` and is a max-heap by default. In order to make it a min-heap implement the `Ord` trait explicitly on the type which is stored in the heap."],["BitVec","A space-efficient contiguous growable bit array type."],["HashMap","Mapping stored in the contract storage."],["Stash","A stash collection."],["Value","A value on the storage."],["Vec","A contiguous growable array type, written `Vec<T>` but pronounced 'vector'."]],"trait":[["Allocator","Types implementing this trait are storage allocators."],["Flush","Types that are able to flush their state into the contract storage."]]});